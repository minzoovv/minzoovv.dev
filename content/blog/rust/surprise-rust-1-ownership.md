---
title: 놀라운 Rust! - Ownership (1)
date: 2020-02-21 00:02:23
category: rust
draft: false
---

<p style="font-size:12px">
  <i>
      본 내용은 <b>러스트 프로그래밍 공식 가이드</b> 책을 기반으로 번역, 정리한 글입니다. <br> 오역이 있거나 잘못된 개념이 있으면 지적 부탁드립니다 :pray:
  </i>
</p>

<hr>
<br>

이번 포스팅에서는 Rust의 가장 근간이 되는 개념인 **소유권**에 대해서 이야기 할 것이다.  
하지만 그러기 앞서서, 소유권이 존재하는 이유와 관련된 질문으로 포스팅을 시작하고자 한다.

## 프로그래밍 언어에서 메모리를 관리하는 방법?

모든 프로그램에서는 프로그램 실행 중에 메모리에 대한 관리가 필요하다.  
이 메모리를 관리하는 전형적인 방법에는 다음과 같은 것들이 있다.

1. **Garbage Collector**  
   Garbage Collector는 사용하지 않는, 주소를 잃어버려서 사용할 수 없는 메모리에 대해서 자동으로 해제하는 작업을 해주는 프로그램이다. Python, Go 등 다양한 언어들에서 언어 자체에서 제공하는 GC를 사용하여 사용하지 않는 변수에 대해서 자동으로 메모리 해제를 해준다.

2. **직접 메모리 allocation, free**  
   우리가 기본적으로 아는 GC가 없는 C, C++과 같은 언어에서는 alloc(), free() 등의 문법을 사용하여 직접 동적 메모리를 할당을 해준다. 코드 레벨에서 메모리 할당, 비할당이 일어난다.

3. **Rust에서는?**  
   Rust에서는 `소유권`이라는 특별한 개념을 이용하여 이러한 메모리 할당과 해제를 세세하게 컨트롤 할 수 있다.

그러면 지금부터 이 소유권이라는 개념에 대해 살펴보도록 하자.

## 소유권

소유권은 말 그대로 한 변수가 어떠한 데이터를 가지고 있는 `권리` 이다.

Rust에서는 소유권과 관련하여 다음의 Rule이 존재한다.

- 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있다.
- 특정 시점에 값의 소유자는 단 하나뿐이다.
- 소유자가 범위를 벗어나면 그 값은 제거된다.

### 유효범위?

위의 Rule에서 언급된 것 처럼, 기본적으로 Rust의 모든 값들은 변수의 `유효 범위`가 존재한다. 한 변수의 유효 범위는 해당 변수가 선언 된 시점 부터 해당 `블록`이 끝난 시점까지이다.

```rust
	fn main(){
		let s = “hello”;

	} // 이 범위까지가 s라는 변수의 유효범위이다.
```

이러한 기본적인 불변 데이터는 해당 범위의 스택에 저장되고, 이 범위를 벗어나면 스택에서 제거가 된다.
하지만 `힙 메모리`를 사용하는 `가변 데이터`는 조금 더 복잡한 작업이 필요하다.

### Rust의 가변 데이터?

가장 우리가 대표적으로 사용하는 가변 문자열인 `String` 타입을 이용해서 소유권에 대해서 살펴보도록 하자.

알다시피, `String`타입은 `힙 메모리`를 사용하는 가변 데이터이다.  
우리는 이러한 힙 메모리에 대해서 운영체제를 통해 2가지를 일을 해주어야 한다.

1. 운영체제에 힙 메모리 요청을 해야 한다.
2. 그리고, 사용이 끝나면 운영체제에 다시 돌려주어야 한다.

1번의 내용은 직접 개발자가 `String::from`을 통해서 메모리를 할당하여 실행한다. 하지만, 2번째 절차는 조금 다르다.

```rust{4}
	fn main(){
		let s = String::from(“hello”);

	} // 바로 이 부분!
```

**바로 이 부분!** 이라고 표시한 부분에서는 우리가 위에서 알다시피 블록의 유효범위가 끝나는, 메모리에 대한 free가 일어나야 하는 부분이다. 보통의 언어라면 저 구간에서 해당 메모리에 대해서 `free()`라는 함수를 호출해서 해당 데이터에 대한 메모리를 돌려주어야 할 것이다.

하지만, Rust에서는 블록이 끝나는 지점, 즉 s의 범위를 벗어나는 부분에서 `drop()`이라는 함수가 자동으로 호출됨으로써 자원에 대한 메모리를 운영체제에 돌려주게 된다.

이렇게 어떤 요소의 수명주기 마지막에 자원을 해제하는 패턴을 `초기화에 의한 자원 획득(RAII 패턴)`이라고 부르며, Rust의 drop() 함수는 이 RAII 패턴과 유사하다.

## 소유권의 다양한 작용

우리는 보통 다양한 데이터를 여러 변수에 할당하며 데이터를 운용한다. 이러한 과정에서 데이터에 대한 소유권의 여러 행동이 일어난다. 한번 살펴보도록 하자.

1. **이동(Move)**

처음 소개하는 이 `이동`이라는 행위가 소유권을 배우면서 처음 새로움을 느끼는 부분일 것이다. 코드를 먼저 살펴보자.

```rust{5}
	fn main(){
	let s1 = String::from(“hi”);
	let s2 = s1;

	// println!(“{}”, s1); -> 소유권이 넘어가 유효하지 않다.
}
```

위의 코드를 보면 `s1`에 가변 문자열인 `”hi”`가 할당이 되고, 그 가변 데이터에 대한 소유권이 `s2`로 넘어간다. 그 상황에서 `s1`은 `”hi”`라는 가변 문자열에 대한 소유권을 잃게 된다. 그래서 이렇게 소유권이 이동 된 후 `s1`을 통해 데이터를 사용하려고 하면 에러가 난다.

**메모리 동작 관점**에서 위의 코드를 살펴보면, `s1`은 변수가 스택 메모리에 저장 되어 있고, 해당 힙 메모리를 가리키는 포인터가 저장된다. 하지만 `s2`에 `s1`이 가지고 있던 소유권을 넘겨줌으로써, `s2` 변수가 스택 메모리에 생성되고, `s1`이 가리키는 힙 메모리의 포인터를 가지게 된다.
그리고 `s1`이 더 이상 유효한 메모리가 아니라고 판단하고, 마지막에 블록이 끝나는 시점에 `s2`에 대해서만 `drop()`함수를 호출하며 메모리를 해제해준다.

이런 개념을 우리는 다른 프로그래밍 언어에서 이미 많이 접해보았다.  
Rust는 가변 데이터에 대해 늘 **얕은 복사**만 실행한다.

<br>

2. **복제(Clone)**

물론, 힙 메모리를 통째로 복사하는 **깊은 복사**도 가능하다.  
`clone()` 메서드를 이용해서 이를 시행할 수 있다.

```rust
	fn main(){
	let s1 = String::from(“hi”);
	let s2 = s1.clone();

	println!(“{}, {}”, s1, s2);  // 깊은 복사로, 실행이 가능하다.
}
```

<br>

3. **복사(Copy)**

앞서 말했듯이, 가변 데이터가 아닌 일반 **리터럴 데이터**에 대해서는 소유권에 대해서 `복사` 동작이 일어난다. 각 변수에 대한 스택 메모리에 해당 값이 그대로 복사되더라도 메모리 해제에 대한 부담이 없기 때문이다.

```rust
	fn main(){
	let s1 = ‘a’;
	let s2 = s1; // literal에 대한 복사만 일어난다.

	println!(“{}, {}”, s1, s2); // a a, 에러가 나지 않는다
}
```

<hr>
<br>

이렇게 소유권의 개념과 기본적인 동작에 대해서 알아보았다.

지금 소개한 예제들은 간단한 예제들이 대부분이지만, 우리는 이것보다 더 복잡하게 데이터를 넘겨받고, 사용하게 될 것이다. 그런 상황에서 일어나는 소유권의 개념에 대해서 다음 포스팅에서 이어가도록 하겠다.

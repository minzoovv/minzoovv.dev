---
title: 놀라운 Rust! - Ownership (2)
date: 2020-02-22 03:02:41
category: rust
draft: false
---

<p style="font-size:12px">
  <i>
      본 내용은 <b>러스트 프로그래밍 공식 가이드</b> 책을 기반으로 번역, 정리한 글입니다. <br> 오역이 있거나 잘못된 개념이 있으면 지적 부탁드립니다 :pray:
  </i>
</p>

<hr>
<br>

저번 포스팅에 이어서 계속해서 소유권에 대해 이야기 해보려고 한다.
이제는 단순히 변수 선언을 넘어서 함수로 변수가 넘어다닐 때에 소유권이 어떻게 동작하는지 알아보도록 하자.

## 함수에서의 소유권

값에 함수를 전달하는 것은, 해당 값을 **변수에 대입하는 것**과 동일하다.  
따라서 우리가 앞에서 다루었던 소유권에 대한 이동, 복사가 동일하게 이루어진다.

```rust
fn main(){
		let s = String::from(“function!”);
		let i = 1;

		let i1 = copy_ownership(i);
		println!(“{}”, i);
		let s1 = give_and_take_ownership(s);
		println!(“{}”, s); // 이 코드는 에러가 난다. s1으로 수정해야 한다.
}

fn copy_ownership(i: u32){
		println!(“{}”, i);
		i // 마지막 라인 return 시, return 예악어 없이 값만 적으면 된다.
}

fn give_and_take_ownership(s: String){
		println!(“{}”, s);
		s
}

```

위의 코드를 살펴보면, `copy_ownership()` 함수에서는 변수 `i`의 타입인 `u32` 타입에 대해서는 소유권의 복사가 일어나, 후에 `main()` 함수에서 변수 `i`에 대해 접근할 때에도 에러가 나지 않는다.  
하지만, `String` 자료형을 가지는 변수 `s`는 가변 데이터이기 때문에, `give_and_take_ownership()` 함수 안의 변수 `s`로 해당 변수의 소유권이 이동된다.

이렇게 함수 안으로 이동된 변수에 대한 소유권은 다시 리턴시켜 caller 블록 내로 이동시킬 수 있다. `give_and_take_ownership()` 함수가 `s`를 리턴하면, `main()` 함수 내의 변수 `s1`으로 소유권이 이동되어 계속 해당 데이터에 접근할 수 있게 된다.

하지만 위의 코드 처럼 `give_and_take_ownership()` 함수 안의 변수 `s`를 리턴하지 않는다면, 해당 블록에서 `s`에 대한 유효범위가 끝나 함수가 끝날 때 해당 값은 `drop()`되게 된다.

매번 이렇게 데이터를 사용하기 위해 소유권을 넘기고 다시 받는 작업을 해야하는 걸까?  
당연하게도, 이를 해결할 수 있는 다른 방법이 존재한다.

## 참조와 대여

우리는 소유권을 가져오는 대신, 해당 객체에 대한 **참조**를 이용 할 수 있다.  
코드를 먼저 살펴보자.

```rust
	fn main(){
		let s = String::from(“function!”);
		get_reference(&s);
	}

	fn get_reference(&s: &String){
		println!(“{}”, s);
}
```

해당 변수에 대한 참조를 가져오기 위해서는 해당 변수에 `앰퍼센트(&)` 기호를 붙여, 참조를 만들면 된다.  
위처럼 변수 `s`의 참조는 `&s`가 되고, `get_reference()` 함수에도 참조를 변수로 받아오기 때문에, 시그니처에도 `&`를 넣어준다.

이렇게 참조를 이용하게 되면 해당 객체의 소유권을 가지지 않고 해당 객체의 데이터에 접근할 수 있다.

그리고 말한대로 참조는 소유권을 가지지 않기 때문에, `get_reference()` 함수가 끝나더라도 `drop()`함수가 호출되지 않는다. 또한 해당 참조를 리턴할 필요도 없다.

이렇게 함수의 매개 변수로 참조를 전달하는 것을 **대여(Borrow)**라고 한다.

```rust
	fn main(){
		let s = String::from(“function!”);
		change(&s);
	}

	fn change(s: &String){
		s.push_str(“I’m here”); // 과연 이 실행은 될까?
}
```

위처럼 참조에 대해서 수정을 하는 동작에 대해서는 어떻게 될까? 작동하지 않고 에러가 난다.  
번수가 기본적으로 불변인 것 처럼 참조도 불변이고, 참조 값의 변경이 불가능하다.

## 가변 참조

하지만, 우리는 한 변수에 대해서 `가변 참조`라는 것을 얻을 수 있다. 위의 에러를 고치면 이렇게 된다.

```rust
	fn main(){
		let mut s = String::from(“function!”);
		change(&mut s);
	}

	fn change(s: &mut String){
		s.push_str(“I’m here”); // 이 실행은 된다!
}
```

`mut` 는 해당 변수를 변경 가능하게 만들 수 있게 하는 예약어이다.  
일단 기존의 변수 자체를 mutable하게 만들고, 그 변수에 대해서 `&mut` 을 앞에 붙여 가변 참조를 만들게 되면, 가변 참조를 통해서 해당 변수를 변경할 수 있다.

하지만, 가변 참조에도 제약이 하나 존재한다. 그것은 바로 **특정 범위 내의 특정 데이터에 대한 가변 참조는 1개만 존재해야 한다**는 것이다. 이 때문에 한 범위 내에서는 여러 개의 가변 참조를 만들 수 없다.

이러한 제약 떄문에, 손쉽게 프로그램 상에서 발생하는 `data race (데이터 경합)`을 컴파일 시점에서 방지할 수 있다.  
보통 이런 상황에서 데이터 경합이 일어난다.

- 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근 시
- 최소한 하나의 포인터가 데이터를 쓰기 위해 사용될 시
- 데이터에 대한 접근을 동기화할 수 있는 매커니즘이 없을 시

이런 데이터 경합은 런타임에서 원인을 파악하고 수정하기 어려운데, Rust에서는 데이터 경합이 발생하는 코드에 대해 컴파일을 허용하지 않음으로서 문제를 예방한다.

<br>

또한 기억해야 할 또 하나의 가변 참조에 대한 제약은 **불변 참조를 이미 사용 중일 때 가변 참조를 사용할 수 없다**는 것이다.

```Rust
fn main(){

	let mut s = String(“hi”);
	let a = &s;
	let b = &s; // 문제 x
	let c = &mut s; // 에러가 발생
}

```

우리는 `불변 참조`를 생성함으로써 해당 변수에 대해 읽기 권한을 가지게 된다. 이 상황에서 `가변 참조`를 생성하게 된다면 그 변수에 대해서 변경이 일어나게 할 가능성이 생긴다. Rust는 이 상황에서 `가변 참조`의 선언을 컴파일 레벨에서 막아 해당 불변 참조에 대해서 시점에 따라 다른 값이 나올 수 있게 할 여지를 막아버린다.

추가로, 해당 변수에 대해 읽기 권한만을 가지는 `불변 참조`는 한 범위에서 여러 개 만드는 것은 가능하다.

## 죽은 참조

보통 포인터를 사용하는 언어는 죽은 포인터로 에러가 나는 경우가 많다.  
죽은 포인터란, 이미 해제되어 다른 정보를 저장하는 메모리를 계속해서 참조하는 포인터를 말한다.  
Rust에서는 이러한 죽은 포인터가 발생하지 않도록 컴파일러가 작동한다.

```rust
fn main(){

	let ref_to_nothing = dangle();
}

fn dangle() -> &String {

	let s = String::from(“will be dead”);

	&s // 죽은 변수에 대한 참조를 리턴하게 된다.
}
```

위의 코드를 컴파일 하면 `dangle()` 함수의 `&String` 부분에서 이런 에러가 난다.

_Expected lifetime parameter._  
_This function’s return type contains a borrowed value,_  
_but there is no value for it to be borrowed from._

첫 문장에서는 수명에 대해 언급을 하는데, 이는 후에 10장에서 나올 개념이므로 넘어가고,  
그 아래의 문장을 직역하자면, 다음과 같다.

_이 함수는 대여값을 리턴하려 하지만, 실제 대여할 값이 존재하지 않는다._

위의 `dangle()` 함수 안의 변수 `s`가 이 함수가 끝나는 순간 `drop()`을 호출하므로, 이런 죽은 참조를 리턴하는 코드를 컴파일러에서 허용해주지 않는다.

## 다른 형태의 참조, 슬라이스

슬라이스도 소유권을 갖지 않는 타입이다.

> ### 슬라이스?

**슬라이스**는 컬렉션 내의 연속된 요소를 참조하는 타입이다.  
String에서도 문자열 슬라이스를 이용해서 String 안의 일부 요소를 참조하는데, 다음과 같이 사용하면 된다.

```rust
let s = String::from(“this is”);
let this = &s[0..5];
let is = &s[6..8];
let is2 = &s[0..];
let all = &s[..];
```

위에서 살펴보았던 전체 참조 `&s`를 가져오는 방법과 유사하지만, 뒤에 `[0..5]` 를 붙여 문자열의 일부에 대해서만 참조를 가져올 수 있다. 위의 내용처럼 슬라이스는 [`시작 인덱스`..`끝 인덱스 +1`]의 형식을 이용해, `(끝 인덱스 - 시작 인덱스)` 까지의 길이의 데이터를 저장하는 구조체이다.

또한 마지막 바이트를 전부 포함하려면 뒤의 값을 생략하면 되고, 전체를 가져오려면 양쪽 값을 생략하면 된다.

이를 이용해서 어떤 값의 참조 중에서 일부 참조만을 가져와, 해당 가변 데이터를 변경하는 실행이 있을 경우 컴파일 레벨에서 에러가 발생하도록 만들 수 있다.

백문이 불여일견이라고, 코드를 살펴보자.

```rust

fn main(){
	let mut s = String::from(“hello it’s me”);
	let word = first_word(&s);
	s.clear(); // 이 실행은 에러가 난다.
 	println!(“{}”, word);
}

fn first_word(s: &String) -> &s {
	let bytes = s.as_bytes();
	for (i, &item) in bytes.iter().enumerate() {
		if item == b’ ‘ {
			return &s[0..i];
		}
	}
	&s[..]
}
```

위의 코드는 문자열 슬라이스를 이용해서 해당 문자열의 첫번째 단어를 리턴해주는 코드이다. `main()` 함수 안의 변수 `s`의 참조가 `first_word()`라는 함수로 들어가고, 그 변수 참조의 일부가 return이 되면서, 해당 변수에 대한 불변 참조가 계속 이어지고 있다. 그렇기 때문에, `s.clear()` 실행은 에러가 난다. (불변 참조가 존재하고 있는 상황에서 해당 변수를 변경할 수 없기 때문이다.)

아래와 같이 `first_word()`라는 함수가 단순히 첫번째 단어를 알기 위해 그 단어가 끝나는 인덱스 값을 return 해주었더라면 변수에 대한 참조를 가지고 있지 않아 컴파일러가 해당 코드에 대한 logical error을 잡을 수 없을 것이고, 해당 변수가 변경되면 그렇게 나온 인덱스 값은 쓸모 없는 값이 되어버렸을 것이다.

```rust
fn first_word(s: &String) -> usize {
	let bytes = s.as_bytes();
	for (i, &item) in bytes.iter().enumerate() {
		if item == b’ ‘ {
			return i;
		}
	}
	s.len()
}
// 이 first_word() 함수는 main에서 s가 변경 된다면 의미 없는 return값이 될 것이다.
```

하지만 이렇게 슬라이스 타입을 사용해서 참조를 넘겨주므로써 그러한 의미 없는 데이터 생성을 막을 수 있게 된다.

> ### 문자열 리터럴 = 슬라이스?!

슬라이스를 이해했다면, 우리가 기존에 알고 있던 문자열 리터럴에 대해서도 이해할 수 있다.

```rust
	let s = “Hello, world!”;
```

위의 문자열 리터럴의 타입은 바로 우리가 위에서 익숙하게 보았던 `&str`이다. 즉 바이너리의 어느 한 지점을 가리키는 슬라이스라는 뜻이다. 따라서 문자열 참조는 늘 불변이다. `&str`가 불변참조이기 때문이다!

따라서 우리가 썼던 `first_word()` 함수의 시그니처 또한 바꿔 줄 수 있다.
함수에 넣어주었던 `String` 참조 대신 슬라이스 참조를 넣어주면 될 것이다.

```rust
fn first_word(s: &str) -> usize { … }

fn main(){

	let s = String::from(“surprise rust!”);
	let word = first_word(&s[..]);
}
```

이렇게 코드를 짜게 되면, `first_word()`라는 함수는 `String`객체에도, 문자열 리터럴에도 사용될 수 있는 함수가 된다.

### 다른 타입의 슬라이스

위의 문자열 슬라이스는 문자열에 특화된 슬라이스이며, 다른 타입을 위한 슬라이스도 존재한다. 우리가 아는 Array 에서도 Array의 일부만 가져오려고 할 때 나오는 타입이 해당 Array가 가지는 변수에 대한 슬라이스 타입이라고 생각하면 된다.

```rust
let a = [1,2,3,4];
let slice = &a[1..]; // &[i32] 타입의 slice
```

이러한 형태의 슬라이스는 모든 종류의 컬렉션에 대해 활용 할 수 있다.

<br>
<hr>
<br>

지금까지 소유권에 대해, 그리고 소유권을 기반으로 하는 여러 행위들에 대해서 파악했다.  
러스트는 이렇게 사용자에게 변수에 대한 통제권을 제공하지만, 소유권에 위배되는 코드에 대해 제대로 에러를 내고, 범위가 벗어난 소유자들에 대해서 데이터를 자동으로 해제해줌으로서 메모리에 대한 안전한 사용을 도모하고 디버깅을 위한 추가 코드를 작성할 필요를 없애준다.

다음은 Rust에서 데이터를 그룹화 하는 여러가지 개념들에 대해서 알아볼 예정이다. 여기서 포스팅을 마치도록 하겠다.
